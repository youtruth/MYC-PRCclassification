dir.create("results/signatures", showWarnings = FALSE)

# -------------------- Packages --------------------
req_cran <- c("tidyverse","matrixStats","glmnet","ggrepel")
for(p in req_cran) if(!requireNamespace(p, quietly=TRUE)) install.packages(p)
invisible(lapply(req_cran, library, character.only=TRUE))

if (!requireNamespace("BiocManager", quietly=TRUE)) install.packages("BiocManager")
bio_pkgs <- c("edgeR","archetypes","depmap","ExperimentHub")
for (bp in bio_pkgs) if (!requireNamespace(bp, quietly=TRUE)) BiocManager::install(bp, ask=FALSE, update=FALSE)
BiocManager::install("depmap")
# (선택) GDSC
if (!requireNamespace("PharmacoGx", quietly=TRUE)) {
  try(BiocManager::install("PharmacoGx", ask=FALSE, update=FALSE), silent=TRUE)
}

# -------------------- 0) Load data --------------------
grp <- readr::read_tsv("MYC_PRC_group_info.txt", col_types = "cc") %>%
  setNames(c("sample","subtype")) %>%
  mutate(subtype = toupper(subtype))

cnt <- readr::read_tsv("MYC_PRC_rawData_20250115.txt")
if (!"gene" %in% names(cnt)) {
  nm <- names(cnt); names(cnt)[1] <- "gene"
}

# 공통 샘플 정렬
samples <- intersect(grp$sample, setdiff(names(cnt), "gene"))
stopifnot(length(samples) >= 20)
grp <- grp %>% filter(sample %in% samples) %>% slice(match(samples, sample))
expr <- cnt %>% select(all_of(c("gene", samples))) %>% distinct(gene, .keep_all = TRUE)
mat <- as.matrix(expr[,-1]); rownames(mat) <- expr$gene

# -------------------- 1) 정규화 & QC --------------------
# CPM + log2; 0-분산 유전자 제거
libsize <- colSums(mat)
cpm <- t(t(mat) / libsize * 1e6)
logcpm <- log2(cpm + 1)
vars <- matrixStats::rowVars(logcpm); logcpm <- logcpm[vars > 0, , drop=FALSE]

# 변이 큰 유전자 Top 1000
madv <- matrixStats::rowMads(logcpm)
top <- names(sort(madv, decreasing=TRUE))[seq_len(min(1000, nrow(logcpm)))]
X <- t(scale(t(logcpm[top, , drop=FALSE])))

# -------------------- 2) Conformal (CV+, 5-fold, alpha=0.10) --------------------
alpha <- 0.10
y <- ifelse(grp$subtype == "MYC", 1, 0)



# 변이 큰 유전자 Top 1000 선정 이후 ↓ 이 두 줄로 교체
X <- t(logcpm[top, , drop=FALSE])   # samples x genes
X <- scale(X)                       # 열(유전자) 기준 z-score

# 안전장치(옵션): 결측/상수 열 제거
X <- X[, apply(X, 2, function(z) sd(z, na.rm=TRUE) > 0), drop=FALSE]
X[!is.finite(X)] <- 0

# 반드시 맞는지 확인
stopifnot(nrow(X) == length(y))     # 행 = 샘플 수




K <- 5
foldid <- sample(rep_len(1:K, length.out=length(y)))

p_hat <- rep(NA_real_, length(y)); nonconf <- rep(NA_real_, length(y))
for (k in 1:K) {
  tr <- foldid != k; te <- !tr
  fit <- glmnet::cv.glmnet(X[tr,], y[tr], family="binomial", alpha=1, type.measure="class")
  pr <- as.numeric(predict(fit, X[te,], s="lambda.min", type="response"))
  p_hat[te] <- pr
  nonconf[te] <- ifelse(y[te]==1, 1 - pr, pr)
}
t_MYC <- 1 - p_hat; t_PRC <- p_hat
n <- length(y)
count_ge <- function(v, thr) sum(v >= thr)
p_MYC <- sapply(t_MYC, function(th) (count_ge(nonconf, th) + 1) / (n + 1))
p_PRC <- sapply(t_PRC, function(th) (count_ge(nonconf, th) + 1) / (n + 1))

predset <- ifelse(p_MYC > alpha & p_PRC > alpha, "{MYC,PRC}",
                  ifelse(p_MYC > alpha, "{MYC}",
                         ifelse(p_PRC > alpha, "{PRC}", "{}")))



# 1) list-컬럼 방지: 문자형으로 강제
conf_tab <- conf_tab %>%
  dplyr::mutate(prediction_set = as.character(prediction_set))

# 2) plyr/dplyr 충돌 방지: dplyr::count 를 명시적으로 호출
conf_counts <- conf_tab %>%
  dplyr::count(prediction_set, name = "n")

# (선택) 보기 좋게 정렬
ord <- c("{MYC}","{PRC}","{MYC,PRC}","{}")
conf_counts <- conf_counts %>%
  dplyr::mutate(prediction_set = factor(prediction_set, levels = ord)) %>%
  dplyr::arrange(prediction_set)

# 3) 저장
readr::write_csv(conf_counts, "박사님/conformal_set_counts.csv")





ggplot(conf_counts, aes(prediction_set, n)) +
  geom_col() + labs(title=paste0("Conformal sets (alpha=",alpha,")"), x="", y="Count") +
  theme_classic()
ggsave("results/conformal_sets_bar.png", width=4.6, height=3.3, dpi=300)

# -------------------- 3) Archetypal analysis (진짜) --------------------
# archetypes::stepArchetypes (K=2)
library(archetypes)
coef_mat <- coef(aa)

# 1) 반드시 '순수 행렬'로 변환 (drop=TRUE/[[ ]] 대신 한 번에 강제)
coef_mat <- as.matrix(coef_mat)
storage.mode(coef_mat) <- "double"           # numeric 보장

# 2) 샘플 순서 정렬(중요) — coef_mat의 행과 grp$sample 일치시킴
grp2 <- grp[ match(rownames(coef_mat), grp$sample), , drop=FALSE ]
stopifnot(all(rownames(coef_mat) == grp2$sample))

# 3) MYC 라벨을 0/1 numeric로
y_bin <- as.numeric(grp2$subtype == "MYC")

# 4) 상관계수 계산 (결측/비유효값 방지)
r1 <- suppressWarnings(cor(coef_mat[, 1], y_bin, use = "complete.obs"))
r2 <- suppressWarnings(cor(coef_mat[, 2], y_bin, use = "complete.obs"))

myc_side <- if (r1 >= r2) 1 else 2
alpha_MYC <- coef_mat[, myc_side]

arch_df <- tibble::tibble(
  sample   = rownames(coef_mat),
  alpha_MYC = as.numeric(alpha_MYC),
  subtype   = grp2$subtype
)
readr::write_csv(arch_df, "results/archetype_alpha_k2.csv")
coef_mat <- coef(aa)  # samples x 2, 각 원형 혼합비(합=1)
# 어떤 원형이 MYC 쪽인지 결정
myc_side <- if (cor(coef_mat[,1], as.numeric(grp$subtype=="MYC")) >=
                cor(coef_mat[,2], as.numeric(grp$subtype=="MYC"))) 1 else 2
alpha_MYC <- coef_mat[, myc_side]
arch_df <- tibble(sample=rownames(coef_mat), alpha_MYC=alpha_MYC,
                  subtype=grp$subtype)
readr::write_csv(arch_df, "results/archetype_alpha_k2.csv")

ggplot(arch_df, aes(subtype, alpha_MYC, fill=subtype)) +
  geom_boxplot(outlier.shape=NA, alpha=0.6) + geom_jitter(width=0.12, alpha=0.7) +
  scale_y_continuous(limits=c(0,1)) +
  labs(title="Archetypal analysis (K=2): alpha(MYC)", x="", y="alpha (MYC archetype)") +
  theme_classic() + theme(legend.position="none")
ggsave("results/archetype_alpha_box.png", width=4.6, height=3.3, dpi=300)
